List of stuffs to do (in French, sorry):

ExtendeD
========

* Pouvoir envoyer un fichier en le glissant déplaçant vers la calc
serait pratique, comme sous VTI.

* Un bug non reproduit : l'ouverture du débugger faisait défiler très
rapidement toute seule la fenêtre Code sans s'arrêter à n'importe quel
adresses (trop hautes pour être du code).


Kevin
=====

* Un truc qui serait bien serait une fonction "breakpoint on program entry".
Mais comme la feature dans VTI est implémentée plutôt avec les pieds, il
faudrait qu'on discute de ça ensemble pour ne pas faire les mêmes erreurs.
Le problème n°1 dans VTI est sa manière foireuse de récupérer l'adresse du
heap. Voici une méthode qui fonctionne:
 move.l $c8,a3 ;get ROM call table address
 cmp.l #$441,-4(a3) ;check if HeapTable is present
 bcs.s getheap_ams1
 lea.l $441*4(a3),a0 ;get address of HeapTable
 move.l a0,(a4)+ ;set Heap
 bra.s getheap_ams2
getheap_ams1:
 move.l HeapDeref*4(a3),a0
 clr.w (a4)+
 move.w 8(a0),(a4)+ ;set Heap
getheap_ams2:
Ceci devrait être facilement implémentable en C dans l'émulateur, ce ne sont
que des lookups d'adresses. Ce code pourrait aussi être utilisé pour
afficher une fenêtre "Handles" comme le fait VTI.

*  Il y a un bogue avec le débogueur et les touches: prends un AMS 2.0x ou 3.0x, mets 
un breakpoint sur le trap #11, lance un programme ASM (même Exec "4e750000" suffit), 
quitte le débogueur, appuie sur n'importe quelle touche, il réagit comme si c'était ENTER. 
Seulement après avoir désactivé le BP sur le trap 11 et appuyé sur ENTER une autre fois, 
TiEmu reprend son comportement normal.
Ce problème est apparemment causée par le fait qu'une touche (ENTER) est appuyée au moment 
où on entre dans le débogueur. (Le BP sur le trap 11 s'active au moment où ENTER est encore 
appuyé.)

* Au passage, c'est normal que AMS 3.01 pour V200 au format v2u m'affiche 
"Hardware Version -1.00"? Le pointeur du basecode parameter block pointe vers une zone 
qui ne contient que des FFFF.
AMS 2.09 pour V200 aussi.
Bon, c'est général pour les ??u, ça me le fait aussi pour un 89u de TI-89. VTI donne 
carrément n'importe quoi comme pointeur, mais au moins les routines le reconnaissaient 
et prenaient une valeur par défaut à la place. Mais -1 est carrément bizarre.
Il faudrait initialiser le boot par défaut pour qu'on lise 2 pour le champ gateArray du 
basecode parameter block, parce que c'est la version que tu émules par défaut. (Si ça ne 
correspond pas, il y aura des ennuis avec les ndg et autres.)
Pardon: pour qu'on se comprenne, je parle du hardware parameter block, pas du basecode 
parameter block.

* Au fait, même si avec les touches pour changer d'apps bloquées, la calculatrice émulée se bloque quand-même par occasion. Il y a plein de moyens de causer ce bogue avec la souris seulement. Il faudrait vraiment que tu corriges ce bogue à la racine plutôt que de chercher des workarounds.[08:36:41] <Kevin Kofler> Et ensuite:
* le blocage des touches ne sert à rien, la machine émulée ne reçoit quand-même pas les touches même si tu empêches leur fonction système (et comme déjà dit, le bogue de la machine bloquée est quand-même là),
[08:36:41] <Kevin Kofler> * je trouve ta manière de bloquer ces touches à l'initialisation de TiEmu et de ne les réactiver qu'à la fin très brutale. Si tu penses que c'est une bonne idée de garder cette feature, il faudrait trouver un moyen de ne le faire que si TiEmu est la fenêtre active.

Bref, je pense que le mieux est de désactiver ce code.
[08:36:41] <Kevin Kofler> Une manière simple de reproduire le bogue du blocage de l'engine: appuie sur le bouton droit de la souris sur l'écran, garde-le appuyé jusqu'à ce que le menu apparaît, puis relâche-le sans rien sélectionner dans le menu -> hop, émulateur bloqué.

* [10:42:52] <Kevin Kofler> Ton code pour les bsr F-Line est faux, next_pc = curr_pc + ti68k_debug_disassemble(curr_pc, &output); donnera curr_pc + 2, alors qu'il faut curr_pc + 4 pour FFEE et curr_pc + 6 pour FFF0.
[10:42:53] <Kevin Kofler> Et sinon, il y a un autre cas particulier bizarre, je ne sais pas s'il vaut le coup de le traîter, mais _bcd_math est un ROM_CALL qui s'appelle comme ça:
* n'importe quelle méthode d'appel d'un ROM_CALL (jsr, F-Line etc.)
* 2 octets: opcode FPU
et le ROM_CALL saute ces 2 octets en retournant, donc retourne à next_pc+2. Si tu veux gérer ça, tu devrais regarder le target du jsr ou F-Line et comparer avec l'adresse de _bcd_math.
[10:42:53] <Kevin Kofler> Précisions:
* la "FPU" est purement émulée en logiciel par _bcd_math, et les opcodes ne correspondent à aucune FPU réelle
* Pour le F-Line, tu peux comparer l'opcode avec 0xF8B5, mais pour les appels par jsr, tu n'as pas d'autre choix que de tester le target du saut pour savoir si on saute vers _bcd_math ou aillers

Lionel
======

* Un bug bizarre, dont les instructions de
reproduction semblent être:
        * utiliser un AMS "récent" (2.07+), sur une 92+ ou
V200 (peut-être 89 aussi ?).
        * aller dans la fenêtre de debug, partie sélection
des ROM_CALLs, sélectionner l'un d'entre eux
(_bcd_math par exemple).
        * passer à une AMS 2.05 (testé: ROM dump de 89 avec
certificate).
        * aller dans la fenêtre de debug: TIEmu est parti
dans le décor, je ne sais pas s'il exécute ou pas

+ Autre détail: les handles sont tous 2 octets trop
gros. Et je revérifierai, mais je ne suis pas sûr que
tous les handles soient affichés (je ne trouve pas des
fichiers créés).

* Il y a un petit bug dans la fenêtre des breakpoints
(c'est le bug mineur dont je ne me souvenais plus
l'autre fois): quand on a breaké le debugger par F11,
le mode de break est inconnu, et ça affiche <unknown
(bug)>...

roms
====

* MOVEA.W diassembled as MOVEA.L (HeapDeref)

-------------
+ done
- in progress
* to do...

List of stuffs to do (in French, sorry):

ExtendeD
========

* none

Kevin
=====

* Un truc qui serait bien serait une fonction "breakpoint on program entry".
Mais comme la feature dans VTI est implémentée plutôt avec les pieds, il
faudrait qu'on discute de ça ensemble pour ne pas faire les mêmes erreurs.
Le problème n°1 dans VTI est sa manière foireuse de récupérer l'adresse du
heap. Voici une méthode qui fonctionne:
 move.l $c8,a3 ;get ROM call table address
 cmp.l #$441,-4(a3) ;check if HeapTable is present
 bcs.s getheap_ams1
 lea.l $441*4(a3),a0 ;get address of HeapTable
 move.l a0,(a4)+ ;set Heap
 bra.s getheap_ams2
getheap_ams1:
 move.l HeapDeref*4(a3),a0
 clr.w (a4)+
 move.w 8(a0),(a4)+ ;set Heap
getheap_ams2:
Ceci devrait être facilement implémentable en C dans l'émulateur, ce ne sont
que des lookups d'adresses. Ce code pourrait aussi être utilisé pour
afficher une fenêtre "Handles" comme le fait VTI.

*  Il y a un bogue avec le débogueur et les touches: prends un AMS 2.0x ou 3.0x, mets 
un breakpoint sur le trap #11, lance un programme ASM (même Exec "4e750000" suffit), 
quitte le débogueur, appuie sur n'importe quelle touche, il réagit comme si c'était ENTER. 
Seulement après avoir désactivé le BP sur le trap 11 et appuyé sur ENTER une autre fois, 
TiEmu reprend son comportement normal.
Ce problème est apparemment causée par le fait qu'une touche (ENTER) est appuyée au moment 
où on entre dans le débogueur. (Le BP sur le trap 11 s'active au moment où ENTER est encore 
appuyé.)

* Et sinon, il y a un autre cas particulier bizarre, je ne sais pas 
s'il vaut le coup de le traîter, mais _bcd_math est un ROM_CALL qui s'appelle comme ça:
- n'importe quelle méthode d'appel d'un ROM_CALL (jsr, F-Line etc.)
- 2 octets: opcode FPU
et le ROM_CALL saute ces 2 octets en retournant, donc retourne à next_pc+2. Si tu veux 
gérer ça, tu devrais regarder le target du jsr ou F-Line et comparer avec l'adresse de 
_bcd_math.
Précisions:
- la "FPU" est purement émulée en logiciel par _bcd_math, et les opcodes ne correspondent 
à aucune FPU réelle
- Pour le F-Line, tu peux comparer l'opcode avec 0xF8B5, mais pour les appels par jsr, 
tu n'as pas d'autre choix que de tester le target du saut pour savoir si on saute vers 
_bcd_math ou aillers

Il y en a un dans TIGCCLIB:

__floatunssibf:
 link.w %a6,#-36
 pea.l 8(%a6)
 move.l 0xC8,%a0
 move.l 0xB5*4(%a0),%a0 /* _bcd_math */
 jsr (%a0)
 .word 0x6B30 /* bcdMove | bcdUnsigned | bcdAbsSrc | bcdR0 */
 move.l -10(%a6),%d0
 move.l -6(%a6),%d1
 move.w -2(%a6),%d2
 unlk %a6
 rts

Le .word 0x6B30 est le code de la pseudo-FPU dont je parle. Et ce n'est pas
exécuté par le processeur, _bcd_math rajoute 2 octets à l'adresse de retour.

Au fait, si tu veux savoir exactement les opcodes permis par _bcd_math et peut-être les afficher de manière lisible, cf. ftp://ftp.ti.com/pub/graph-ti/calc-apps/89/asm/exec.inc . (Mais ça ne va marcher que pour les appels que tu peux détecter à l'avance, évidemment.)

Lionel
======

* Un bug bizarre, dont les instructions de
reproduction semblent être:
        * utiliser un AMS "récent" (2.07+), sur une 92+ ou
V200 (peut-être 89 aussi ?).
        * aller dans la fenêtre de debug, partie sélection
des ROM_CALLs, sélectionner l'un d'entre eux
(_bcd_math par exemple).
        * passer à une AMS 2.05 (testé: ROM dump de 89 avec
certificate).
        * aller dans la fenêtre de debug: TIEmu est parti
dans le décor, je ne sais pas s'il exécute ou pas


roms
====

* MOVEA.W diassembled as MOVEA.L (HeapDeref)

* rom calls & handles to make more reliable

-------------
+ done
- in progress
* to do...

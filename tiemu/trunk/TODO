List of stuffs to do:

ExtendeD:

* bug sur Step Out

* Les Step over sont anormalement lent, sans raison. Certains bsr de
l'AMS ont des sous-bsr qui ont eux-mêmes plusieurs sous-bsr, etc.,
certains step over sur ces bsr mettent plusieurs dizaines de seconde à
aboutir.

* Un Step To sur une instruction suffisamment loin de l'instruction
courante n'a aucun effet, c'est bizarre...

+ Comment fait-on pour faire passer en 'disable' un breakpoint ? Il y
a deux boutons dans la fenêtre qui mais il sont toujours grisés, je ne
sais plus à quoi ils servent, c'est pas ça ?

* Le scroll d'instructions vers le bas n'est pas bon du tout, Il
n'avance pas d'instruction en instruction, mais se décale parfois, on
s'y perd complètement.

* Si après un breakpoint sur instruction se fait toucher, et si on
fait 'run', le même breakpoint se fait retoucher, il faudrait plutôt
continuer.

* Je ne suis pas sûr que les data breakpoints fionctionnent
correctement. Si je place un breakpoint 'single byte' à 0, il n'est
jamais atteint par le code du reset, alors qu'il y a bien une écriture
d'un long mot à 0.

+ La couleur de l'écran fait partie de la skin, comme sous VTI ? Ne
serait-ce pas mieux d'avoir du noir sur blanc sur 92+, parce que le
jaune c'est pas top :)

+ Ce serait bien que la fenêtre PC log possède un bouton pour afficher
dans la fenêtre Code l'adresse sélectionnée, ou que ça fonctionne par
double-clique.
En tout cas c'est une fenêtre bien pratique, elle m'a permis de
trouver (ou de re-trouver, c'est le même problème depuis plusieurs
versions :)) facilement le problème avec la Titanium.

* Un bouton pour éditer un breakpoint serait pas mal (afficher une fenêtre
comme la fenêtre 'Add breakpoint', mais initialisée avec les valeurs
du breakpoint choisi).

==

* La fenêtre Memory n'est pas toujours rafraîchie. Il y a le bouton
refresh, mais on ne pense pas toujours à l'utiliser. Elle n'est pas
rafraîchie notamment lorsque un breakpoint est touché, ce serait
possible de forcer le rafraîchissement à ce moment là ?

* Pour le problème de scroll d'instructions gênant dont je te parlais
: va n'importe où dans l'AMS où il y a des instructions valides,
scroll instruction par instruction vers le bas, tu verras que sur
certaines instructions le scroll est effectué en haut, mais pas en bas
de la fenêtre (la dernière instruction reste la même).

* Quelques idées pas forcément très urgentes mais qui seraient
intéressantes à implémenter :
- L'AMS utilise le registre a6 comme frame pointer, et accède
relativement à ce registre aux variables locales créées et aux
paramètres de la fonction exécutée.
Le problème est qu'avec des instructions de type cmp.w -$54(a6),d0, on
voudrait savoir ce qu'il y a à la variable à l'offset $54 : il faut
alors sortir une calculatrice hexa, calculer l'adresse réelle et aller
dans la fenêtre Memory trouver la valeur.
L'idéal serait d'avoir dans la même fenêtre que stack frame, un memory
dumper qui ressemble à celui de la pile, mais avec les offsets
relatifs au registre a6 plutôt que des adresses réelles (offsets
positifs et négatifs pour pouvoir regarder à la fois les variables
locales et les paramètres de la fonction). Par exemple :
-6  0084
-4  5600
-2  0000
0   0090
2   4924
4   2828
6   0000
Il faudrait que la fenêtre puisse être scrollable à l'infini dans les
deux sens, on ne peut pas savoir la quantité de variables que la
fonction peut utiliser.
Si c'est trop compliquer à réaliser, écrire à côté de l'instruction
l'adresse correspondant à -$54(a6) dans l'exemple précédent suffirait
pour pouvoir se débrouiller, mais serait beaucoup moins bien.

* Un système de breakpoint temporaire sur instruction, comme sous GDB,
serait pratique (breakpoint qui disparaît la première fois qu'il est
touché) : il m'arrive souvent de placer un breakpoint après un bsr ou
un jsr de l'AMS avant de faire un step into dans la sous-routine au
cas où elle serait trop profonde et que j'abandonne le déboguage à
quelques niveaux d'appels plus profond. Je fais un run et mon
breakpoint est touché; je l'enlève et je continue. Un breakpoint
temporaire éviterait d'avoir à l'enlever à chaque fois.


Kevin:

- Je ne sais pas si on peut y faire quelque chose, mais Alt+ESC, Ctrl+ESC,
Alt+TAB (quand on les appuie en même temps et pas l'une après l'autre) sont
avalées par Windows, pour Alt+F4, Windows ne le voit pas, mais TiEmu non
plus, et il y a probablement d'autres combines de touches "suspectes".

- Si j'appuie sur la touche Windows et que je reviens à TiEmu ensuite, il
ne répond plus à aucun appui de touches (mais on peut le fermer à travers le
popup au moins). L'"engine" est "stoppée" et pas re"start"ée.

Lionel:

* le transfert d'un fichier vers TIEmu par F10 donne
une erreur 400 dans la fenêtre command-line (mais n'a
pas l'air de planter l'émulateur). Il faut faire un
Reset Calculator pour avoir une calculette à nouveau
d'aplomb.

* La fenêtre qui affiche les noms de ROM_CALLs est 
difficile à utiliser, car on ne peut pas accéder à 
un ROM_CALL en tapant les premières lettres, et il 
faut savoir le numéro du ROM_CALL pour pouvoir y 
accéder. A l'affichage, inverse simplement juste le 
nom et le numéro (en gardant l'adresse, c'est bien).
Au fait, si on sélectionne un ROM_CALL qui a une 
adresse invalide (ce qui arrive souvent quand la 
table des ROM_CALLs est trouvée à 0x000000), par 
exemple l'adresse 30390020, le désassembleur devrait 
aller à l'adresse 390020 (les 24 bits de poids 
faible), comme le fait le Memory View, plutôt que 
d'aller à l'adresse 303900.

* j'ai de nouveau des problèmes avec le caractère 0x09
dans la fenêtre ASCII de la memory view (Win ME ?).

-------------
+ done
- in progress
* to do...
